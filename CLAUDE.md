# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Heek-chat is a Rust-based chat application with text messaging and P2P voice/video calls. The project consists of three workspace members:
- **heek-chat-lib**: Shared types, RPC service definitions, and transport utilities
- **heek-chat-server**: Backend server handling authentication, channels, and signaling
- **heek-chat-desktop**: egui-based desktop client application

## Build Commands

```bash
# Build entire workspace
cargo build

# Build specific package
cargo build --package heek-chat-server
cargo build --package heek-chat-desktop
cargo build --package heek-chat-lib
```

## Architecture

### Communication Protocol

The application uses a **hybrid communication model** with application-level multiplexing:

1. **RPC (tarpc)**: For request-response operations (user management, channels, messages)
   - Uses CBOR serialization
   - Runs over WebSocket with **Binary messages**

2. **Server Events**: For server-initiated notifications (RTC session events)
   - Uses CBOR serialization
   - Transmitted via WebSocket **Binary messages**
   - Multiplexed with RPC messages over the same WebSocket connection

3. **Multiplexing Layer**: Single WebSocket connection carries both RPC and server events
   - `MultiplexedMessage<Rpc>` enum wraps both RPC messages and Events
   - Server spawns two tasks per connection:
     - **Incoming task**: Demultiplexes WebSocket messages into RPC requests (events from clients are ignored)
     - **Outgoing task**: Multiplexes RPC responses and server events using `tokio::select!`
   - Connection cleanup via oneshot channel that signals when WebSocket tasks exit
   - See `heek-chat-server/src/connection.rs` for implementation

### Authentication Flow

- **Firebase Authentication** with REST API (not SDK)
- Supports Email/Password and Google OAuth
- OAuth flow uses temporary HTTP server for callback handling
- JWT tokens verified with RSA-256 signature checking
- Server-side: `firebase_verify.rs` fetches Firebase public keys and validates tokens
- Client-side: `firebase_auth.rs` handles sign-in and OAuth flow

### RPC Service Definition

Defined in `heek-chat-lib/src/lib.rs` using `#[tarpc::service]` macro:
- User operations: join, get_me, get_user, update_profile
- Channel operations: create_channel, list_channels, join_channel, leave_channel, invite_to_channel
- Message operations: send_message, get_messages
- RTC operations: join_rtc_session, leave_rtc_session, offer/answer/ice_candidate methods

### Type System

- `UserID` and `ChannelID` are type aliases for `Uuid`
- `Event` enum wraps server-initiated events (RTCSession events, errors)
- `RTCSession` tracks active P2P voice/video sessions per channel
- All shared types use serde for serialization

### Voice/Video Architecture (Planned)

**P2P WebRTC** (not SFU):
- Encryption (low priority)
   - Custom encrypted transport using **AEGIS-256** (not DTLS/SRTP)
   - Server generates unique encryption key per session
- UDP sockets with multiple SSRC for audio/video
- H.264 video encoding with GPU acceleration
- Screen capture via CapSoftware/scap library

**Current State**: Signaling infrastructure implemented using multiplexed events over WebSocket. RTC session events (UserJoined, UserLeft, OfferReceived, AnswerReceived, IceCandidateReceived) are fully implemented and broadcast to all participant connections.

### E2E Encryption (low priority)

- All user content (messages, profiles) encrypted with shared "server key" (AEGIS-256)
- Server does NOT know the server key
- Users must pre-share the key out-of-band
- Voice/video uses separate per-sender encryption keys generated by server

### Storage

- **Current**: In-memory HashMaps (dev/testing)
- **Planned**: PostgreSQL with tokio-postgres
- Server uses `Arc<RwLock<HashMap<...>>>` for concurrent access

## Key Implementation Details

### Desktop Client (`heek-chat-desktop/src/main.rs`)

- **App struct**: Main application state with tokio runtime
- **OAuth flow**: Temporary HTTP server on random port for Google sign-in callbacks
- **Firebase token**: Stored and passed with every RPC call for authentication
- **Event handling**: Polls event receiver in `check_events()` during UI update loop
- **UI**: egui immediate mode GUI with login screen and main chat interface

### Server (`heek-chat-server/src/main.rs`)

- **ChatServer**: Clone-able struct with Arc-wrapped storage
  - `user_connections`: Maps UserID to set of ConnectionIDs (supports multiple connections per user)
  - `event_senders`: Maps ConnectionID to event channel sender
- **Authentication**: Every RPC method starts with `authenticate()` or `authenticate_id_token_only()`
  - First authentication call registers connection in `user_connections` map
- **Invitation system**: Token-based server joining (expires after 7 days)
- **Connection handling**:
  - Each connection gets unique ConnectionID
  - Event sender registered in `event_senders` map
  - Cleanup task spawned to remove from both maps on disconnect
  - Connection struct includes `disconnect_rx` oneshot channel for cleanup signaling
- **Event broadcasting**:
  - RTC events (UserJoined, UserLeft, OfferReceived, etc.) sent to all connections of target users
  - Uses `user_connections` to find ConnectionIDs, then `event_senders` to send events
- **Concurrency**: Uses `buffer_unordered(32)` to handle up to 32 concurrent client connections

### Connection Lifecycle

**Connection establishment** (`heek-chat-server/src/connection.rs`):
1. TCP connection accepted and upgraded to WebSocket
2. WebSocket split into read/write halves
3. Oneshot channel created for disconnect signaling
4. Two tasks spawned:
   - Incoming: reads WebSocket messages, demultiplexes into RPC channel
   - Outgoing: multiplexes RPC responses and events, writes to WebSocket
5. Both tasks signal disconnect via oneshot channel when they exit
6. Connection struct returned with RPC transport, event sender, and disconnect receiver

**Connection registration** (`heek-chat-server/src/main.rs`):
1. Unique ConnectionID generated
2. Event sender stored in `event_senders` map by ConnectionID
3. Cleanup task spawned, waiting on `disconnect_rx`
4. On first RPC call with authentication, ConnectionID added to `user_connections` map

**Connection cleanup** (automatic on disconnect):
1. Disconnect signal triggers cleanup task
2. ConnectionID removed from `event_senders` map
3. ConnectionID removed from all entries in `user_connections` map
4. Empty user entries removed from `user_connections` map

## Important Technical Constraints

- **Single server** - no scale-out considerations
- WebSocket on port 8080
- Firebase project ID and client ID are hardcoded (see `firebase_auth.rs` and `firebase_verify.rs`)
